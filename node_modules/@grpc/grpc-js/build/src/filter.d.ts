/// <reference types="node" />
<<<<<<< HEAD
import { Call, StatusObject, WriteObject } from './call-stream';
import { Metadata } from './metadata';
/**
 * Filter classes represent related per-call logic and state that is primarily
 * used to modify incoming and outgoing data
=======
import { StatusObject, WriteObject } from './call-interface';
import { Metadata } from './metadata';
/**
 * Filter classes represent related per-call logic and state that is primarily
 * used to modify incoming and outgoing data. All async filters can be
 * rejected. The rejection error must be a StatusObject, and a rejection will
 * cause the call to end with that status.
>>>>>>> origin/main-placeholder
 */
export interface Filter {
    sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;
    receiveMetadata(metadata: Metadata): Metadata;
    sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;
    receiveMessage(message: Promise<Buffer>): Promise<Buffer>;
    receiveTrailers(status: StatusObject): StatusObject;
<<<<<<< HEAD
    refresh(): void;
=======
>>>>>>> origin/main-placeholder
}
export declare abstract class BaseFilter implements Filter {
    sendMetadata(metadata: Promise<Metadata>): Promise<Metadata>;
    receiveMetadata(metadata: Metadata): Metadata;
    sendMessage(message: Promise<WriteObject>): Promise<WriteObject>;
    receiveMessage(message: Promise<Buffer>): Promise<Buffer>;
    receiveTrailers(status: StatusObject): StatusObject;
<<<<<<< HEAD
    refresh(): void;
}
export interface FilterFactory<T extends Filter> {
    createFilter(callStream: Call): T;
=======
}
export interface FilterFactory<T extends Filter> {
    createFilter(): T;
>>>>>>> origin/main-placeholder
}
